<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Happy Birthday Clover</title>
    <!-- åŠ è½½ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        /* æ‘„åƒå¤´èƒŒæ™¯å±‚ */
        .input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0.2;
            transform: scaleX(-1);
            filter: grayscale(80%) contrast(1.2);
        }

        /* ç²’å­å±‚ */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Dialogue Box */
        #start-screen {
            text-align: center;
            color: white;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.75); /*ç¨å¾®åŠ æ·±èƒŒæ™¯ä»¥çªå‡ºæ–‡å­—*/
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 105, 180, 0.3);
            box-shadow: 0 0 40px rgba(255, 105, 180, 0.2);
            max-width: 90%;
            width: 400px;
            transition: all 0.3s ease;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #dialogue-text {
            font-weight: 300;
            font-size: 1.4rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #fff;
            white-space: pre-wrap; /* æ”¯æŒæ¢è¡Œ */
        }

        /* Highlight Speaker Name */
        .speaker-name {
            color: #ff69b4;
            font-weight: bold;
            font-size: 1.1rem;
            display: block;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .choices-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        button.choice-btn {
            padding: 15px 20px;
            font-size: 1.1rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        button.choice-btn:hover {
            background: linear-gradient(45deg, #ff69b4, #9370db);
            border-color: transparent;
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(147, 112, 219, 0.4);
        }
        
        button.choice-btn.primary {
             background: linear-gradient(45deg, #ff69b4, #9370db);
             border: none;
             font-weight: bold;
        }

        /* Status & Hints */
        #status-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1rem;
            text-align: center;
            width: 100%;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        #gesture-hint {
            margin-top: 5px;
            font-weight: bold;
            color: #ff69b4;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.8);
        }

        #music-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.3s;
            pointer-events: auto;
        }
        #music-toggle:hover { opacity: 1; }
        
        #error-msg {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 10px;
            display: none;
        }

        /* Loading Spinner for buttons */
        .loading-dots:after {
            content: ' .';
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
            40% { color: white; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0);}
            60% { text-shadow: .25em 0 0 white, .5em 0 0 rgba(0,0,0,0);}
            80%, 100% { text-shadow: .25em 0 0 white, .5em 0 0 white;}
        }

    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="start-screen">
            <div id="dialogue-content">
                <!-- Content injected by JS -->
                <div id="dialogue-text">åŠ è½½ä¸­...</div>
                <div class="choices-container" id="choices-box"></div>
            </div>
            <p id="error-msg"></p>
        </div>
    </div>

    <div id="status-bar" class="hidden">
        <span id="loading-text">ç³»ç»Ÿåˆå§‹åŒ–...</span>
        <div id="gesture-hint">Waiting for input...</div>
    </div>

    <div id="music-toggle" class="hidden">ğŸµ</div>

    <!-- WebGL Container -->
    <div id="canvas-container"></div>

    <!-- Video Element -->
    <video class="input_video" playsinline></video>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        
        // --- Script / Dialogue Data ---
        const SCRIPT = {
            step1: {
                text: "<span class='speaker-name'>Leslie:</span>é•¿äº†ä¸€å²ï¼Œæ™ºå•† +1ï¼Œ\nä½ è¿˜ç›¸ä¿¡é­”æ³•å—ï¼Ÿ",
                choices: [
                    { text: "A. ç›¸ä¿¡ âœ¨", next: "start" },
                    { text: "B. ä¸ç›¸ä¿¡ ğŸŒš", next: "step2" }
                ]
            },
            step2: {
                text: "<span class='speaker-name'>Leslie:</span>æˆ‘ä¹Ÿè®¸çœŸçš„æ‡‚ä¸€ç‚¹é­”æ³•å“¦ï¼Œ\nä½ æƒ³çœ‹ä¸€ä¸‹å—ï¼Ÿ",
                choices: [
                    { text: "A. æƒ³ ğŸ™‹â€â™€ï¸", next: "start" },
                    { text: "B. ä¸æƒ³ ğŸ™…â€â™€ï¸", next: "step3" }
                ]
            },
            step3: {
                text: "<span class='speaker-name'>Leslie:</span>é‚£â€¦ä½ æƒ³ä¸æƒ³çœ‹çœ‹ï¼Œ\nè¿™ä¸ªä¸–ç•Œä¸ºä½ å·å·å‡†å¤‡çš„å°æƒŠå–œï¼Ÿ",
                choices: [
                    { text: "A. æƒ³ ğŸ‘€", next: "start" },
                    { text: "B. ä¸æƒ³ ğŸ˜‘", next: "step4" }
                ]
            },
            step4: {
                text: "<span class='speaker-name'>Leslie:</span>ğŸ˜¯ å¯æ˜¯â€¦æˆ‘å·²ç»å‡†å¤‡å¥½äº†â€¦\nCloverï¼Œä½ ç¡®å®šâ€¦çœŸçš„ä¸æƒ³çœ‹çœ‹å—ï¼Ÿ",
                choices: [
                    { text: "A. å¥½å§ ğŸ‘€", next: "start" },
                    { text: "B. æˆ‘æ‰ä¸æƒ³å‘¢ ğŸ™…â€â™€ï¸", next: "step5" }
                ]
            },
            step5: {
                text: "<span class='speaker-name'>Leslie:</span>ğŸ˜¢ å¯æ˜¯â€¦â€¦\nğŸ€ è¿™ä»½é­”æ³•ï¼Œæ˜¯ä¸“å±äºä½ çš„ã€‚\næ‰€ä»¥â€¦â€¦æˆ‘è¿˜æ˜¯æƒ³ç»™ä½ çœ‹çœ‹ã€‚\nè¯·æ”¶ä¸‹è¿™ä»½ç”Ÿæ—¥é­”æ³•å§ âœ¨",
                choices: [
                    { text: "ğŸ æ”¶ä¸‹é­”æ³•", next: "start", primary: true }
                ]
            }
        };

        // --- Configuration ---
        const CONFIG = {
            particleCount: 5000, 
            colors: [0xff69b4, 0xffb7c5, 0x9370db, 0xffffff], 
            textSequence: ["3", "2", "1", "Clover", "Happy", "Birthday", "ç¥ä½ ", "å¼€å¿ƒ", "å¿«ä¹", "æ¯ä¸€å¤©", "â¤ï¸"],
            cameraZ: 100,
            textScale: 0.6,
        };

        // --- Global Variables ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = []; 
        let currentPositions = []; 
        let randomPositions = []; 
        let isScattered = true;
        let dispersionLevel = 1.0; 
        let currentTextIndex = 0;
        let audio;
        let isAudioPlaying = false;
        
        let isTouching = false; 
        let hasAssembledOnce = false; 
        let libsLoaded = false;

        // --- DOM Elements ---
        const startScreen = document.getElementById('start-screen');
        const dialogueText = document.getElementById('dialogue-text');
        const choicesBox = document.getElementById('choices-box');
        const statusBar = document.getElementById('status-bar');
        const loadingText = document.getElementById('loading-text');
        const gestureHint = document.getElementById('gesture-hint');
        const musicToggle = document.getElementById('music-toggle');
        const errorMsg = document.getElementById('error-msg');

        // --- Dialogue Logic ---
        function renderStep(stepKey) {
            const stepData = SCRIPT[stepKey];
            dialogueText.innerHTML = stepData.text;
            choicesBox.innerHTML = '';

            stepData.choices.forEach(choice => {
                const btn = document.createElement('button');
                btn.className = `choice-btn ${choice.primary ? 'primary' : ''}`;
                btn.innerText = choice.text;
                
                // If libs not loaded yet, show loading state on button
                if (choice.next === 'start' && !libsLoaded) {
                    btn.disabled = true;
                    btn.innerHTML = choice.text + " <span class='loading-dots'>(èµ„æºåŠ è½½ä¸­)</span>";
                    btn.dataset.originalText = choice.text;
                }

                btn.onclick = () => {
                    if (choice.next === 'start') {
                        startSurprise();
                    } else {
                        renderStep(choice.next);
                    }
                };
                choicesBox.appendChild(btn);
            });
        }

        // Initial Render
        renderStep('step1');

        // Check Libs and enable buttons
        function checkLibs() {
            if (window.Hands && window.Camera && THREE) {
                libsLoaded = true;
                // Enable any disabled buttons
                const buttons = document.querySelectorAll('.choice-btn');
                buttons.forEach(btn => {
                    if (btn.disabled) {
                        btn.disabled = false;
                        if (btn.dataset.originalText) {
                            btn.innerText = btn.dataset.originalText;
                        }
                    }
                });
            } else {
                setTimeout(checkLibs, 500);
            }
        }
        checkLibs();

        // --- Start Sequence ---
        function startSurprise() {
            startScreen.classList.add('hidden');
            statusBar.classList.remove('hidden');
            musicToggle.classList.remove('hidden');

            setTimeout(async () => {
                try {
                    try { initAudio(); } catch(e) { console.warn("Audio init failed", e); }
                    
                    initThree();
                    generateTextTargets(CONFIG.textSequence[0]);
                    
                    try {
                        await initMediaPipe();
                    } catch (e) {
                        console.warn("MediaPipe init failed.", e);
                        loadingText.innerText = "ä½¿ç”¨é¼ æ ‡/è§¦æ‘¸æ¨¡å¼";
                        gestureHint.innerText = "æŒ‰ä½å±å¹•èšé›†ç²’å­";
                    }

                    animate();
                } catch (err) {
                    console.error("Critical Error:", err);
                    alert("å¯åŠ¨å‡ºç°é—®é¢˜ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚\n" + err.message);
                    startScreen.classList.remove('hidden');
                    errorMsg.style.display = 'block';
                    errorMsg.innerText = "Error: " + err.message;
                }
            }, 100);
        }

        // --- Audio ---
        function initAudio() {
            audio = new Audio('https://cdn.pixabay.com/audio/2022/02/07/audio_1303830d1c.mp3'); 
            audio.loop = true;
            audio.volume = 0.5;
            
            musicToggle.addEventListener('click', () => {
                if(isAudioPlaying) {
                    audio.pause();
                    musicToggle.style.opacity = '0.5';
                } else {
                    audio.play();
                    musicToggle.style.opacity = '1';
                }
                isAudioPlaying = !isAudioPlaying;
            });
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    isAudioPlaying = true;
                    musicToggle.style.opacity = '1';
                }).catch(error => {
                    isAudioPlaying = false;
                    musicToggle.style.opacity = '0.5';
                });
            }
        }

        // --- Three.js Setup ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.cameraZ;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createParticles();

            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('mousedown', () => { isTouching = true; });
            document.addEventListener('mouseup', () => { isTouching = false; });
            document.addEventListener('touchstart', (e) => { isTouching = true; e.preventDefault(); }, {passive: false});
            document.addEventListener('touchend', () => { isTouching = false; });
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(CONFIG.particleCount * 3);
            const colorArray = new Float32Array(CONFIG.particleCount * 3);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Random scattered positions
                const r = 150 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                randomPositions.push(new THREE.Vector3(x, y, z));
                targetPositions.push(new THREE.Vector3(0, 0, 0));
                
                posArray[i * 3] = x;
                posArray[i * 3 + 1] = y;
                posArray[i * 3 + 2] = z;

                // Colors
                const colorHex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                const color = new THREE.Color(colorHex);
                colorArray[i * 3] = color.r;
                colorArray[i * 3 + 1] = color.g;
                colorArray[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const sprite = getTexture();

            material = new THREE.PointsMaterial({
                size: 3.5, 
                vertexColors: true,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- Text Generation ---
        function generateTextTargets(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 600; 
            const height = 300;
            canvas.width = width;
            canvas.height = height;

            ctx.clearRect(0, 0, width, height); 
            
            let fontSize = 180; 
            if (text.length > 5) fontSize = 100;
            
            ctx.font = `900 ${fontSize}px Arial, sans-serif`; 
            ctx.fillStyle = '#ffffff'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const tempTargets = [];
            
            const step = 4; 
            for (let y = 0; y < height; y += step) { 
                for (let x = 0; x < width; x += step) {
                    const alpha = data[(y * width + x) * 4 + 3];
                    if (alpha > 128) {
                        const pX = (x - width / 2) * 0.4; 
                        const pY = -(y - height / 2) * 0.4;
                        const pZ = 0;
                        tempTargets.push(new THREE.Vector3(pX, pY, pZ));
                    }
                }
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (i < tempTargets.length) {
                    targetPositions[i] = tempTargets[i];
                } else {
                    targetPositions[i] = tempTargets[i % tempTargets.length];
                }
            }
        }

        async function initMediaPipe() {
            const videoElement = document.querySelector('.input_video');
            
            if (!window.Hands) throw new Error("MediaPipe Hands library not loaded");
            
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            if (!window.Camera) throw new Error("MediaPipe Camera library not loaded");

            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            return cameraUtils.start().then(() => {
                loadingText.innerText = "æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ";
                gestureHint.innerText = "ğŸ‘ å¼ å¼€=æ•£å¼€ | ğŸ‘Œ æåˆ=èšé›†";
            });
        }

        function onHandsResults(results) {
            if (isTouching) return; 

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                let targetLevel = (distance - 0.03) * 6; 
                targetLevel = Math.max(0, Math.min(1, targetLevel)); 
                
                if (targetLevel < 0.3) { 
                    targetLevel = 0;
                    gestureHint.innerText = "âœ¨ ä¿æŒæåˆ (Pinch) âœ¨";
                } else {
                    gestureHint.innerText = "ğŸ‘ å¼ å¼€åŒæ‰‹ (Open)";
                }

                dispersionLevel += (targetLevel - dispersionLevel) * 0.2; 
            } else {
                dispersionLevel += (1 - dispersionLevel) * 0.1;
            }
            
            handleSequenceLogic();
        }

        function handleSequenceLogic() {
            if (dispersionLevel < 0.3) {
                hasAssembledOnce = true;
            }

            if (hasAssembledOnce && dispersionLevel > 0.6) {
                hasAssembledOnce = false;
                switchText();
            }
        }

        function switchText() {
            currentTextIndex = (currentTextIndex + 1) % CONFIG.textSequence.length;
            const nextText = CONFIG.textSequence[currentTextIndex];
            generateTextTargets(nextText);
        }

        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            if (isTouching) {
                dispersionLevel += (0 - dispersionLevel) * 0.15; 
                gestureHint.innerText = "âœ¨ æ¾å¼€ä»¥åˆ‡æ¢ âœ¨";
                handleSequenceLogic();
            } else if (!document.querySelector('.input_video').srcObject) {
                 dispersionLevel += (1 - dispersionLevel) * 0.1;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const currentVec = new THREE.Vector3(positions[ix], positions[iy], positions[iz]);
                const randomVec = randomPositions[i].clone();
                
                randomVec.x += Math.sin(time + i * 0.1) * 3;
                randomVec.y += Math.cos(time + i * 0.05) * 3;

                const textVec = targetPositions[i] || new THREE.Vector3(0,0,0);
                
                const destVec = new THREE.Vector3().lerpVectors(textVec, randomVec, dispersionLevel);

                const speed = 0.1 + (1 - dispersionLevel) * 0.1; 
                currentVec.lerp(destVec, speed);

                positions[ix] = currentVec.x;
                positions[iy] = currentVec.y;
                positions[iz] = currentVec.z;
            }

            geometry.attributes.position.needsUpdate = true;

            camera.position.x = Math.sin(time * 0.1) * 3;
            camera.position.y = Math.cos(time * 0.15) * 3;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
