<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Happy Birthday Clover</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Start Button & Intro */
        #start-screen {
            text-align: center;
            color: white;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.4);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 105, 180, 0.3);
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.2);
            max-width: 90%;
        }

        h1 {
            font-weight: 300;
            font-size: 2rem;
            margin-bottom: 10px;
            letter-spacing: 2px;
            color: #fff;
        }

        .quote {
            font-style: italic;
            color: #ffb7c5;
            margin-bottom: 30px;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        button {
            padding: 15px 40px;
            font-size: 1.2rem;
            background: linear-gradient(45deg, #ff69b4, #9370db);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(147, 112, 219, 0.4);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(147, 112, 219, 0.6);
        }

        /* Status & Hints */
        #status-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            text-align: center;
            width: 100%;
        }

        #gesture-hint {
            margin-top: 5px;
            font-weight: bold;
            color: #ff69b4;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        }

        /* Camera Feed (Hidden, used for processing) */
        .input_video {
            display: none;
        }

        /* Music Toggle */
        #music-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.3s;
            pointer-events: auto;
        }
        #music-toggle:hover { opacity: 1; }

    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="start-screen">
            <h1>For Clover</h1>
            <p class="quote">‚ÄúThis surprise is dedicated to Clover ‚Äî the one who makes my world sparkle.‚Äù</p>
            <button id="start-btn">ÂºÄÂêØÊÉäÂñú ‚ú®</button>
            <p style="font-size: 0.8rem; margin-top: 20px; color: #aaa;">
                ‰∫íÂä®ÊñπÂºèÔºö<br>
                1. ÊëÑÂÉèÂ§¥ÔºöÊçèÂêàÊâãÊåáËÅöÈõÜÔºåÂº†ÂºÄÊâãÊéåÊï£ÂºÄ<br>
                2. Èº†Ê†á/Ëß¶Êë∏ÔºöÊåâ‰ΩèËÅöÈõÜÔºåÊùæÂºÄÊï£ÂºÄ
            </p>
        </div>
    </div>

    <div id="status-bar" class="hidden">
        <span id="loading-text">Á≥ªÁªüÂàùÂßãÂåñ...</span>
        <div id="gesture-hint">Waiting for input...</div>
    </div>

    <div id="music-toggle" class="hidden">üéµ</div>

    <!-- WebGL Container -->
    <div id="canvas-container"></div>

    <!-- Hidden Video Element for MediaPipe -->
    <video class="input_video" playsinline></video>

    <!-- Import Maps for Three.js & MediaPipe -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 4000,
            colors: [0xff69b4, 0xffb7c5, 0x9370db, 0xffffff], // HotPink, LightPink, MediumPurple, White
            textSequence: ["3", "2", "1", "Clover", "Happy", "Birthday", "Á•ù‰Ω†", "ÂºÄÂøÉ", "Âø´‰πê", "ÊØè‰∏ÄÂ§©", "‚ù§Ô∏è"],
            cameraZ: 100,
            textScale: 0.6,
        };

        // --- Global Variables ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = []; 
        let currentPositions = []; 
        let randomPositions = []; 
        let isScattered = true;
        let dispersionLevel = 1.0; // 1 = Scattered, 0 = Assembled
        let currentTextIndex = 0;
        let audio;
        let isAudioPlaying = false;
        
        // Touch/Mouse Fallback state
        let isTouching = false; 
        let hasAssembledOnce = false; 

        // --- Initialization ---
        const startBtn = document.getElementById('start-btn');
        const startScreen = document.getElementById('start-screen');
        const statusBar = document.getElementById('status-bar');
        const loadingText = document.getElementById('loading-text');
        const gestureHint = document.getElementById('gesture-hint');
        const musicToggle = document.getElementById('music-toggle');

        startBtn.addEventListener('click', async () => {
            initAudio();
            
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.classList.add('hidden');
                statusBar.classList.remove('hidden');
                musicToggle.classList.remove('hidden');
            }, 1000);

            initThree();
            generateTextTargets(CONFIG.textSequence[0]);
            
            // Try to init MediaPipe, but fail gracefully if in preview env
            try {
                initMediaPipe();
            } catch (e) {
                console.warn("MediaPipe init failed (likely due to iframe permissions). Using mouse/touch fallback.");
                loadingText.innerText = "‰ΩøÁî®Èº†Ê†á/Ëß¶Êë∏Ê®°Âºè";
                gestureHint.innerText = "Êåâ‰ΩèÂ±èÂπïËÅöÈõÜÁ≤íÂ≠ê";
            }
            
            animate();
        });

        // --- Audio ---
        function initAudio() {
            // Using a simple royalty-free base64 or external link. 
            // External links can be flaky in previews, so we handle errors gently.
            audio = new Audio('https://cdn.pixabay.com/audio/2022/02/07/audio_1303830d1c.mp3'); 
            audio.loop = true;
            audio.volume = 0.5;
            
            musicToggle.addEventListener('click', () => {
                if(isAudioPlaying) {
                    audio.pause();
                    musicToggle.style.opacity = '0.5';
                } else {
                    audio.play();
                    musicToggle.style.opacity = '1';
                }
                isAudioPlaying = !isAudioPlaying;
            });
            
            audio.play().then(() => {
                isAudioPlaying = true;
                musicToggle.style.opacity = '1';
            }).catch(e => {
                console.log("Audio autoplay blocked, user interaction needed");
                isAudioPlaying = false;
                musicToggle.style.opacity = '0.5';
            });
        }

        // --- Three.js Setup ---
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.cameraZ;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createParticles();

            window.addEventListener('resize', onWindowResize);
            
            // Mouse/Touch Fallback
            // Mousedown/Touchstart = Pinch (Assemble)
            document.addEventListener('mousedown', () => { isTouching = true; });
            document.addEventListener('mouseup', () => { isTouching = false; });
            document.addEventListener('touchstart', (e) => { isTouching = true; e.preventDefault(); }, {passive: false});
            document.addEventListener('touchend', () => { isTouching = false; });
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(CONFIG.particleCount * 3);
            const colorArray = new Float32Array(CONFIG.particleCount * 3);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Random scattered positions
                const r = 150 + Math.random() * 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                randomPositions.push(new THREE.Vector3(x, y, z));
                targetPositions.push(new THREE.Vector3(0, 0, 0));
                
                posArray[i * 3] = x;
                posArray[i * 3 + 1] = y;
                posArray[i * 3 + 2] = z;

                // Colors
                const colorHex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                const color = new THREE.Color(colorHex);
                colorArray[i * 3] = color.r;
                colorArray[i * 3 + 1] = color.g;
                colorArray[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const sprite = getTexture();

            material = new THREE.PointsMaterial({
                size: 2.5,
                vertexColors: true,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function generateTextTargets(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 400; 
            const height = 200;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            let fontSize = 100;
            if (text.length > 5) fontSize = 60;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            const tempTargets = [];
            
            // Adjust scan step based on particle density desire
            for (let y = 0; y < height; y += 2) { 
                for (let x = 0; x < width; x += 2) {
                    const alpha = data[(y * width + x) * 4 + 3];
                    if (alpha > 128) {
                        const pX = (x - width / 2) * 0.5;
                        const pY = -(y - height / 2) * 0.5;
                        const pZ = 0;
                        tempTargets.push(new THREE.Vector3(pX, pY, pZ));
                    }
                }
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (i < tempTargets.length) {
                    targetPositions[i] = tempTargets[i];
                } else {
                    // Extras orbit center
                    targetPositions[i] = tempTargets[i % tempTargets.length];
                }
            }
        }

        function initMediaPipe() {
            const videoElement = document.querySelector('.input_video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    loadingText.innerText = "ÊëÑÂÉèÂ§¥ÂêØÂä®ÊàêÂäü";
                    gestureHint.innerText = "üëê Âº†ÂºÄ=Êï£ÂºÄ | üëå ÊçèÂêà=ËÅöÈõÜ";
                })
                .catch(err => {
                    loadingText.innerText = "ÊëÑÂÉèÂ§¥‰∏çÂèØÁî®ÔºåËØ∑‰ΩøÁî®ÁÇπÂáªÊ®°Âºè";
                    gestureHint.innerText = "Êåâ‰ΩèÂ±èÂπïËÅöÈõÜÁ≤íÂ≠ê";
                    console.error("Camera failed:", err);
                });
        }

        function onHandsResults(results) {
            // Priority: Touch > Hand
            if (isTouching) return; // Touch overrides camera

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Map distance: 0.02 (Pinch) -> 0 (Assemble), 0.15 (Open) -> 1 (Scatter)
                let targetLevel = (distance - 0.02) * 8; 
                targetLevel = Math.max(0, Math.min(1, targetLevel)); 
                
                if (targetLevel < 0.2) {
                    targetLevel = 0;
                    gestureHint.innerText = "‚ú® ‰øùÊåÅÊçèÂêà (Pinch) ‚ú®";
                } else {
                    gestureHint.innerText = "üëê Âº†ÂºÄÂèåÊâã (Open)";
                }

                dispersionLevel += (targetLevel - dispersionLevel) * 0.1;
            } else {
                // Default drift back to scattered if no hands/touch
                dispersionLevel += (1 - dispersionLevel) * 0.05;
            }
            
            handleSequenceLogic();
        }

        function handleSequenceLogic() {
            // Logic: Must fully Assemble (level near 0) then Scatter (level near 1) to switch text
            if (dispersionLevel < 0.2) {
                hasAssembledOnce = true;
            }

            if (hasAssembledOnce && dispersionLevel > 0.8) {
                hasAssembledOnce = false;
                switchText();
            }
        }

        function switchText() {
            currentTextIndex = (currentTextIndex + 1) % CONFIG.textSequence.length;
            const nextText = CONFIG.textSequence[currentTextIndex];
            generateTextTargets(nextText);
        }

        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            // Manual Touch Logic override for animate loop
            if (isTouching) {
                // Force assemble
                dispersionLevel += (0 - dispersionLevel) * 0.1;
                gestureHint.innerText = "‚ú® ÊùæÂºÄ‰ª•Êï£Êí≠Á•ùÁ¶è ‚ú®";
                handleSequenceLogic();
            } else if (!document.querySelector('.input_video').srcObject) {
                 // If no camera and no touch, drift to scatter
                 dispersionLevel += (1 - dispersionLevel) * 0.05;
            }

            // Update Particle Positions
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const currentVec = new THREE.Vector3(positions[ix], positions[iy], positions[iz]);
                const randomVec = randomPositions[i].clone();
                
                // Float effect
                randomVec.x += Math.sin(time + i) * 2;
                randomVec.y += Math.cos(time + i * 0.5) * 2;

                const textVec = targetPositions[i] || new THREE.Vector3(0,0,0);
                
                // Interpolate
                const destVec = new THREE.Vector3().lerpVectors(textVec, randomVec, dispersionLevel);

                // Move
                const speed = 0.05 + (1 - dispersionLevel) * 0.05; 
                currentVec.lerp(destVec, speed);

                positions[ix] = currentVec.x;
                positions[iy] = currentVec.y;
                positions[iz] = currentVec.z;
            }

            geometry.attributes.position.needsUpdate = true;

            // Camera float
            camera.position.x = Math.sin(time * 0.2) * 5;
            camera.position.y = Math.cos(time * 0.3) * 5;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
